* Two things Object.is misses is NaN and -0
* checking for Nan is Number.isNan
* checking for -0 is by 1/-0 gives negative infinity
* Infinity is built in in javascript
* another way to check for Nan is Nan != Nan should be true
* Fundamental Objects
** with which we will use new keyword
** Don't use new
** spend more time on this
** new will costruct objects
** not new will change them into primitive types
* conversion or coercion
** ToPrimitive keeps on calling itself unless it gets a primitive value
** toString
*** -0 toString give "0"
* To see the contents of object you can use JSON.stringify
* toBoolean is a lookup and in javascript [] is true
#+BEGIN_SRC javascript
  var y = '5'
  y++                             // This returns number instead of string
  y

#+END_SRC
* Topics
** types
*** Primitive types
*** abstract operations
*** coercion
*** equality
*** typescript, flow
** scope
** objects
* Types
** In javascript everything is not an object
** primitive types are undefined, null, boolean, string, symbol, number and object
*** undeclared, null, function, array, bignint
*** objects
**** object, function, array
** undefined means does not have a value now
** values returned from typeof operator are strings
*** typeof null returns object
*** typeof function returns function  
*** undefined vs undeclared vs uninitialized
**** in javascript using of undeclared object doesn't throw error but says it is undefined
** special values
*** NaN
**** invalid number 
**** NaN === NaN is false
**** NaN != NaN returns true
**** isNaN can be used to check if value is NaN
**** but isNaN('my son age') returns true which is a problem, it coerces value passed to it to a number and then evaluates it
**** so Number.isNaN should be used 
**** type of NaN is number
*** -0
#+BEGIN_SRC javascript
    var trendRate = -0
    trendRate.toString()            // returns "0" bad idea
    trendRate === 0                 // returns true bad idea
    Object.is(trendRate, -0)        // returns true good idea
    Object.is(trendRate, 0)         // returns false good idea 
  1 / -0 == -Infinity               // gives true
#+END_SRC
*** value / -0 give -Infinity
*** Fundamental objects
**** also called built in objects
**** native functions
**** Don't use new
***** String, Number, Boolean
** Abstract Operations
*** used for type conversion
**** toPrimitive
***** valueOf
***** toString
#+BEGIN_SRC javascript
  toString(-0)                    // gives "0" which is not good

#+END_SRC
***** toString results
****** [] to ""
****** [1,2,3] to 1, 2, 3
****** [null, undefined] to ", "
****** [[[], [], []], []] to ", , ,"
****** [,,,,] to ",,,  "
***** toNumber
****** "" to 0 (root of all evil)
****** "-0" to -0
****** null to 0
****** undefined to NaN
*****  toNumber on object invokes toPrimitive with number hint, so it invokes value of first and toString next and recursively calls valueOf (or toNumber ) on return value of toString
***** toBoolean 
****** less algorithmic more lookup
****** false values "", 0, -0, null, NaN, false, undefined
****** doesn't do coercion just a lookup
***** Cases of coercion
****** string + number gives string
****** unary + on string gives number
****** - operator unary or with string invokes toNumber
****** !! double negate could be explicit
***** Boxing
****** when we use methods on primitives javascript boxes them to objects automatically
*** corner cases
**** [[./corner_cases.png]]
**** [[./corner_cases2.png]]
*** Implicit coercion
**** < operator converts strings to numbers if one of the operand is number
**** it both are strings it wont convert them to numbers 
** double and triple equals
*** == allows coercion
*** === doen not allow coercion
*** == says null and undefined are same
*** == prefers numeric comparison
*** 42 == [42] crazyyyyy
**** == corner cases
***** [] == ![] // this returns true
#+BEGIN_SRC javascript
  var arr1 = []
  var arr2 = []

  arr1 != arr2                    // true because they are objects and they are not same identity

#+END_SRC
**** == booleans corner cases
***** we wouldn't need to do val == true or val == false
* Scope
** where to look for things
** compiler creates plan for scope
** in javascript assigning to variables with same name as global variables in functoins don't create new local variables without var
** if no variable declaration is found at runtime javascript creates a global variable in global scope
** in strict mode global variables are not automatically created if they are not declared
** function expressions add their names in their own local scope
** kyle says prefer named function expressions over anonymous function expressions
