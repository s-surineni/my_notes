* This technique is an example of the factory method design pattern, as we provide a subclass the means to control the type of node that is created within methods of the parent class.
* proxy 
** helps defering create resource intensive objects
** acts as a local representation of remote system
** control access to specific objects
** same interface for real and proxy classes
* decoratory pattern
** notion of a class and relationships like inheritance are static.
** That is, happen at compile time. 
** This means that we cannot make changes to classes while our program is running
** uses aggregation to comabine behaviors at runtime
** Aggregation is used to represent a "has a" or "weak containment" relationship between two objects.
** The aggregation relationship is always one-to-one in the decorator design pattern in order to build up the stack so that one object is on top of another.
** the basic component class must be the first one in the stack
* beahavioral design pattern
** ways that individual objects collaborate to achieve a common goal.
* template method pattern
** The template method defines an algorithm's steps generally, deferring the implementation of some steps to subclasses. 
** concerned with the assignment of responsibilities.
** Think of it like another technique to use when you notice you have two separate classes with very similar functionality in order of operations. 
** implementation
*** need abstract super class
*** methods specific to subclass are abstract
*** there will be one template method that will be calling these abstract methods
** When you notice two classes with a very similar order of operations, you can choose to use a template method.
**  The template method pattern is a practical application of generalization and inheritance.
* chain of responsibility
** series of handler objects that are linked together
** similar to exception handling in java
** All the objects on the chain are handlers that implement a common method handle request declared in an abstract superclass handler.
** we want to make sure that each filter goes through the following steps.
***  First, check if a rule matches. 
*** If it does match, do something specific.
*** If it doesn't match, call the next filter in the list. 
** To achieve this, you can use the Template Pattern that you learned from an earlier lesson to ensure that each class will handle the request in a similar way following the required steps
** The intent of this design pattern is to avoid coupling the sender to the receiver by giving more than one object the chance to handle the request. 
* state pattern
** The state pattern is primarily used when you need to change the behavior of an object based upon the state that it's in at run-time.
** Implementation
*** We will define a state interface with a method for each trigger that a state needs to respond to.
*** And we'll have state classes that implement the state interface.
*** State classes must implement the methods in this interface to respond to each trigger.
*** The vendingmachine class constructor will instantiate each of the state classes
*** The vendingmachine class would also have methods to handle the triggers as before, but now delegates handling to the current state object. 
*** Notice now, how much cleaner the code is, without having long conditionals in these methods.
***  In our example,the vending machine is the context class. 
*** It keeps track of it's current state.
***  When a trigger occurs and a request is asked of a context object, it delegates to a state object to actually handle the request.
***  The state pattern is useful when you need to change the behavior of an object based upon changes to its internal state.
***  You can also use the pattern to simplify methods with long conditionals that depend on the object state.
