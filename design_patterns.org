* This technique is an example of the factory method design pattern, as we provide a subclass the means to control the type of node that is created within methods of the parent class.
* proxy 
** helps defering create resource intensive objects
** acts as a local representation of remote system
** control access to specific objects
** same interface for real and proxy classes
* decoratory pattern
** notion of a class and relationships like inheritance are static.
** That is, happen at compile time. 
** This means that we cannot make changes to classes while our program is running
** uses aggregation to comabine behaviors at runtime
** Aggregation is used to represent a "has a" or "weak containment" relationship between two objects.
** The aggregation relationship is always one-to-one in the decorator design pattern in order to build up the stack so that one object is on top of another.
** the basic component class must be the first one in the stack
* beahavioral design pattern
** ways that individual objects collaborate to achieve a common goal.
* template method pattern
** The template method defines an algorithm's steps generally, deferring the implementation of some steps to subclasses. 
** concerned with the assignment of responsibilities.
** Think of it like another technique to use when you notice you have two separate classes with very similar functionality in order of operations. 
** implementation
*** need abstract super class
*** methods specific to subclass are abstract
*** there will be one template method that will be calling these abstract methods
** When you notice two classes with a very similar order of operations, you can choose to use a template method.
**  The template method pattern is a practical application of generalization and inheritance.
