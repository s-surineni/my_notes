* issues when solid principles are not used
** code fragility
*** tendency of software to break in many places every time it is changed
** code rigidity
*** difficult to change. each change causes a cascade of subsequent changes in dependent modules
* technical debt
** cost of prioritizing fast delivery over code quality for long periods of time
* benefits of solid code
** easy to understand
** changes are faster and have minimal risk
** highly maintainable
** cost effective
* single responsibility principle
** every function, class or module should have one and only one reason to change
** single reason to change = single responsibility
** always identify the reasons to change that your components have and reduce them to a single one
** benefits
*** it makes code easier to understand, fix and maintain
*** classes are less coupled and more resilient to change
*** more testable design
** method
*** identify reasons to change
*** extracting them to different components which are specialized
*** recompiling code so it compiles and works as expected
* Open closed principle
** helps us to write code that is easy to chagne and evolve over time
** classes, functions and modules should be closed for modification and open for extension
** closed for modification
*** each new feature should not modify source code. Source code becomes immutable
** open for extension
*** if it allows us to behave in new ways by writing new code
** if we modify super class subclasses will also break
** so for new feature create a new subclass
** this minimizes risk for regression bugs
** enforces decoupling by isolating changes in specific components
** inheritance produces coupling between derived class and base class(bad). Especially for concrete class
** better approach is strategy pattern. Here we use interfaces
*** and factory class to provide instance of appropriate subclass
** open close principle works well with single responsibility principle
** we used factory pattern in combination with open close principle
** API is a contract between different software components on how they should work together
*** good way to implement an API is to create an interface and provide default implementations for it
*** this way if client needs more functionality they can add their custom classes
*** these kind of frameworks are called extensible
*** an api shouldn't change the exposed class or method
* start small and abstract later when needed
* Liskov substitution principle
** if s is subtype of t, then objects of t can be replaced by s without affecting the functionality of the program
** all about relations between types
** humans think of relations as (is a)
** we should ask ourselves if a particular type is substitutable by other type
** incorrect relationships between types cause unexpected bugs or side effects
** Its hard to find bugs if application breaks Liskov substitution principle
** Example
*** Bird, subtype Ostritch, but ostritch cannot fly. So this will create a bug
** each time we harden preconditions we break liskov substitution principle
** we can violate liskov substitution principle when we implement interfaces
** each time a method throws not implemented exception we are breaking liskov substitution principle
** type check is also another symptom of breaking liskov substitution principle
** two ways to refactor code to make it honor lsp
*** eliminate incorrect relations between objects
**** break inheritance into separate classes (ostritch and bird)
**** fix partially implemented interface by breaking interfaces into smaller pieces
*** tell dont ask to eliminate type checking and type casting
**** override methods to have custom logic in the subclass only instead of doing it at single place
*** make sure derived type can substitute its base type completely
**** dont ask is a question
*** keep base classes small and focused
**** large base classes have high probability of breaking lsp
*** keep interface lean
** empty methods, type checking,hardened preconditions, not-implemented exceptions are signs of violating lsp
