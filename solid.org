* issues when solid principles are not used
** code fragility
*** tendency of software to break in many places every time it is changed
** code rigidity
*** difficult to change. each change causes a cascade of subsequent changes in dependent modules
* technical debt
** cost of prioritizing fast delivery over code quality for long periods of time
* benefits of solid code
** easy to understand
** changes are faster and have minimal risk
** highly maintainable
** cost effective
* single responsibility principle
** every function, class or module should have one and only one reason to change
** single reason to change = single responsibility
** always identify the reasons to change that your components have and reduce them to a single one
** benefits
*** it makes code easier to understand, fix and maintain
*** classes are less coupled and more resilient to change
*** more testable design
** method
*** identify reasons to change
*** extracting them to different components which are specialized
*** recompiling code so it compiles and works as expected
* Open closed principle
** helps us to write code that is easy to chagne and evolve over time
** classes, functions and modules should be closed for modification and open for extension
** closed for modification
*** each new feature should not modify source code. Source code becomes immutable
** open for extension
*** if it allows us to behave in new ways by writing new code
** if we modify super class subclasses will also break
** so for new feature create a new subclass
** this minimizes risk for regression bugs
** enforces decoupling by isolating changes in specific components
** inheritance produces coupling between derived class and base class(bad). Especially for concrete class
** better approach is strategy pattern. Here we use interfaces
*** and factory class to provide instance of appropriate subclass
